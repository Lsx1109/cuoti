有时候人们用四位数字表示一个时间，比如 1106 表示 11 点零 6 分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。
读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。
当小时为个位数时，没有前导的零，例如 5 点 30 分表示为 530；0 点 30 分表示为 030。注意，第二个数字表示的分钟数可能超过 60，也可能是负数。
输入格式：
输入在一行中给出 2 个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。
注意：在起始时间中，当小时为个位数时，没有前导的零，即 5 点 30 分表示为 530；0 点 30 分表示为 030。流逝的分钟数可能超过 60，也可能是负数。
输出格式：
输出不多于四位数字表示的终止时间，当小时为个位数时，没有前导的零。题目保证起始时间和终止时间在同一天内。
输入样例：
1120 110
结尾无空行
输出样例：
1310
结尾无空行
#include<stdio.h>
int main()
{
	int time;
	int mini;
	int hour,minute,total;
	scanf("%d %d",&time,&mini);
	total=time/100*60+time%100;
    
	hour=(total+mini)/60;
    minute=(total+mini)%60;
	
	printf("%d%02d",hour,minute);//不足两位的前位补0 
	
	return 0;
	
	
}


题目内容：
UTC是世界协调时，BJT是北京时间，UTC时间相当于BJT减去8。现在，你的程序要读入一个整数，表示BJT的时和分。整数的个位和十位表示分，百位和千位表示小时。
如果小时小于10，则没有千位部分；如果小时是0，则没有百位部分；如果小时不是0而分小于10分，需要保留十位上的0；
如果小时是0而分小于10分的，则不需要保留十位上的0。如1124表示11点24分，而905表示9点5分，36表示0点36分，7表示0点7分。
有效的输入范围是0到2359，即你的程序不可能从测试服务器读到0到2359以外的输入数据。

你的程序要输出这个时间对应的UTC时间，输出的格式和输入的相同。

提醒：要小心跨日的换算。

输入格式:
一个整数，表示BJT的时和分。
输出格式：
一个整数，表示UTC的时和分。
输入样例：
803
输出样例：
3

#include<stdio.h>
int main()
{
	int BJT, UTC;
	scanf("%d", &BJT);
	if (BJT >= 800)
	{
		UTC = BJT - 800;
	}
	else
	{
		UTC = BJT - 800 + 2400;
	}
	printf("%d", UTC);
	return 0;
}


BCD数是用一个字节来表达两位十进制的数，每四个比特表示一位。所以如果一个BCD数的十六进制是0x12，它表达的就是十进制的12。
但是小明没学过BCD，把所有的BCD数都当作二进制数转换成十进制输出了。于是BCD的0x12被输出成了十进制的18了！
现在，你的程序要读入这个错误的十进制数，然后输出正确的十进制数。提示：你可以把18转换回0x12，然后再转换回12。
输入格式：
输入在一行中给出一个[0, 153]范围内的正整数，保证能转换回有效的BCD数，也就是说这个整数转换成十六进制时不会出现A-F的数字。
输出格式：
输出对应的十进制数。
输入样例：
18
结尾无空行
输出样例：
12

#include <stdio.h>
int main(void) {
    int r, e;

    scanf("%d", &r);
    e = (r / 16) * 10 + r % 16;
    printf("%d\n", e);

    return 0;
}






